function [Iterations,Clustered] = meanShiftClustering(Data,Sigma)
%UNTITLED2 Summary of this function goes here
%   Detailed explanation goes here
    m = size(Data,2);
    invSigma = inv(Sigma);
    Iterations = zeros(size(Data,2),1);
    Clustered = zeros(size(Data));
    
    A = diag(invSigma);
    A = A(:, ones(1, size(Data,2)));
    for i=1:m
        [Iterations(i), Clustered(:,i)] = convergeForPoint(Data(:,i), Data,Sigma,A);
    end
    
    'minimum'
    min(Iterations)
    'maxmimum'
    max(Iterations)
    'average'
    mean(Iterations)
end

function [iteration, shiftedPoint] = convergeForPoint(x,Data,Sigma,A)
   
    firstIteration=true;
    threshold  = 0.001;
    x_prev = x;
    iteration = 0;
    while(firstIteration || norm(x_prev - x)/norm(x) > threshold)
        firstIteration = false;
        iteration = iteration+1;
        x_prev = x;
        %x1 = updateX(x,Data,Sigma);
        x = updateX2(x,Data,Sigma,A);
    end
    shiftedPoint  = x;
end

function [px] = functionValue(x,Data,Sigma)

    Y = cellfun(@(x1)(kernel(x,x1,Sigma)), num2cell(Data,1), 'UniformOutput', true);
    px = sum(Y)/size(Data,2);
    
end
% 
% function [grad] = gradFunction(x,Data)
%         Y = cellfun(@(x1)(kernel(x,x1,sigma)*), num2cell(Data,1), 'UniformOutput', true);
% 
% 
% end

function [x_new] = updateX(x,Data,Sigma)
    Y = cellfun(@(x1)(kernel(x,x1,Sigma)*[x1;1]), num2cell(Data,1), 'UniformOutput', false);
    Y = cell2mat(Y);
    X = Y(1:end-1,:);
    Z = Y(end,:);
    x_new = sum(X,2)/sum(Z);
    
end

function [x_new] = updateX2(x,Data,Sigma, A)
    X=x(:,ones(1,size(Data,2)));
    Y = X-Data;
    %sigmaInverse = inv(Sigma);
    %K = exp(-sqrt((Y'*sigmaInverse*Y)/2))/(sqrt(2*pi)*det(Sigma));
    %t = diag(K)';
    
    
    K = sum((Y'.*Y).*A,1);
    t =  exp(-sqrt((K/2)))/(sqrt(2*pi)*det(Sigma));
    
    T = t(ones(size(Data,1),1),:);
    %x_new = exp(-sqrt(sum(T.*Data,2)));
    x_new = sum(T.*Data,2);
    z_new = sum(t);
    x_new = x_new/z_new;
end


function [val] = kernel(x1,x2,Sigma)
    sigmaInverse = inv(Sigma);
    %assert(Sigma*sigmaInverse == eye(size(Sigma)), 'inverse not computed correctly');
    %Sigma*sigmaInverse -eye(size(Sigma))
    %size(x1)
    val =exp(-sqrt((x1-x2)'*sigmaInverse*(x1-x2)/2))/(sqrt(2*pi)*det(Sigma));
end

